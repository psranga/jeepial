# CsvLang: Pluggable Information Architecture-focused UI Framework (WIP)

## Introduction

* MVC paradigm taken to the max, with assists from relational (SQL) and
  map-reduce programming.

* Goal: Automatic View and Controller modules (the parts that humans
  interact with). Or at least provide *shippable* versions for free
  for the undifferentiated parts of a system.

* Key idea/observation:
  *  Many large rewrites of the View and Controller are simply to stay in tune
     with changes to frameworks -- net value is not always clear.
  *  But the *undifferentiated parts of systems* have overlaps even at the
     Model level -- can we leverage this?

* Why an approach like this might be useful:
  *  Automatic fine-grain composition of UIs
  *  Personalization: automatic personalization of interfaces (color, sorting etc)
  *  Scalability: things like VR are going to increase the number of possibilities
     for View and Controller.
  *  Accessibility: I feel like more automation of View and Controller modules is
     needed to get to the next level of accessibility.

* CSVLang is an exploration of the tradeoffs involved in designing a system
  that prioritizes goals like the above, especially when we don't rule out the
  the use of highly declarative programming models, and are prepared to use
  OS/standard UX patterns.

* Caveat: the "loss of control", the very strict separation of layers, and
  opinionated type system will probably feel strange at first. The hope is
  that the benefits far outweigh the costs.

## Motivation

This is part of my ongoing investigation into what it would take to build an
ultra-performant, low-power, inexpensive home computer, with a software stack
that emphasizes end-user ergonomics and user-data/platform longevity above all.
What gets dropped on the floor is all backward compatibility constraints, and
system-developer ergonomics. All tech/UX is up for questioning/rewriting, with
a healthy skepticism about reinventing the wheel. e.g., IPv6-only with IPv4
being dropped is on the table.

## Core ideas in the programming model

* "Everything is an SQL table": The fundamental data structure is something
  very similar to an in-memory SQL table. Some n fields together are the key,
  and everything else is the data.

* Higher-level type system: In addition to low-level types like 'integer',
  the system has higher-level types like "duration", "timepoint", "date",
  "image".

* Introduces the notion of an "Information Architecture Model" aka IAModel,
  which lies somewhere below the canonical Model, but somewhere above a View in
  closeness to the final rendered output. This is the place where
  *transformations* of the model or the computation of metadata needed by views
  and controllers live.
  
  The IAModel is *strictly additive*: the table corresponding to the model,
  along with some additional columns that the IAModel can populate. This
  definition is key: it allows multiple IAModels to be computed and live
  side-by-side for the same model.

* The hope is that if we figure out how to encode the "information architecture",
  polished views and controllers can be generated by default. Benefit: code
  reuse, harmony in views and controllers between different models.

## Illustrative example: printing a quarterly calendar

To run the code:

    # Prints the calendar for July, Aug, Sep of the year 2022.
    $ lua cal.lua 2022 7 8 9

A printed calendar is somewhat weird when you think about it: the underlying data is technically
just a simple ordered set of (date, day-of-week) pairs i.e.,
it's a *one-dimensional time series*. But the canonical way humans display
that time series is in *two dimensions*.

So there's something interesting going on here that's worth thinking about.

Here's how printing a calendar maps to the IA-based approach:

* **Model:** Method gen_cal_sql() in cal.lua. Returns rows mapping from a column named 'date' to a column named 'dow' that
  contains the day of the week.
  
      date,dow,yy,mm,dd
      2022-07-01,6,2022,07,01
      2022-07-02,7,2022,07,02
      2022-07-03,1,2022,07,03
      2022-07-04,2,2022,07,04
      2022-07-05,3,2022,07,05

* **IAModel:** **This is where we go from 1D to 2D**. See win_gridize() and the
  call to csv_partition() in cal.lua.

  Adds a column monthweek to reflect the week number within the month. Also
  encodes that the day-of-week column is usable as *a* X coordinate, and the
  monthweek column is usable as *a* Y coordinate, with the day-of-month being
  the value *at* that coordinate.

  The field 'date' served as the single "coordinate" for the 1D case.
  Coordinates are all about arranging things in order, and you *will* need as
  many coordinates as there are dimensions.  This is *intrinsic complexity* and
  cannot be wished away.

  But note that this is still abstract: we "reshaped" the data, but we didn't
  say anything about rows and cells as in a table.

  That will be a hint to the rest of the system that *this* IAModel can/should
  be matched up with some View to produce 2D output like on paper, text console,
  or in graphical viewport.

      date,dow,yy,mm,dd,monthweek,ycoor,xcoor,coorvalue
      2022-07-01,6,2022,07,01,1,1,5,1
      2022-07-02,7,2022,07,02,1,1,6,2
      2022-07-03,1,2022,07,03,2,2,0,3
      2022-07-04,2,2022,07,04,2,2,1,4
      2022-07-05,3,2022,07,05,2,2,2,5
      2022-07-06,4,2022,07,06,2,2,3,6

  > **Important note:** If the calendar were for the whole year, the goal is
  that the output from the IAModel will be unchanged, except that more rows
  would be present.

  > For now, I'm staying pretty firm on the idea that rendering decisions such
  as multi-page vs single page should be made as late as possible, even if it
  means adding another stage like IAModel.

  > And if indeed a different IAModel is needed to support the multipage case,
  it would be perfectly reasonable for a second IAModel created by
  post-processing the output of this IAModel to live alongside the Model.

  > The idea is for Views and Controllers to be decoupled and generalized and
  for them to be able to automatically make changes to the Model (for the
  undifferentiated cases).
  
* **View:** this is the part this is customized to the output device. In the
  example, a GridView capable of laying out any IAModel is used. See the call
  to csv_render_as_grid() in cal.lua.

  For console output, this amounts to constructing a matrix in memory and
  printing it, with some standard stuff like automatically resizing column
  widths. Kinda like rendering a HTML table. The X and Y coordinate hints in
  the IAModel are used here. Things like fonts, color for console output are
  all done here. Graphical output, PDF output etc *must* be different Views
  than console output.

  The hope is that a single View capable of displaying a table can be
  automatically used for a wide range of IAModels, with the rich type system
  guiding both matching and rendering policies.

             2022/7           (title is metadata from the IAModel)
      Su Mo Tu We Th Fr Sa    (row headers is metadata from the IAModel)
                      1  2
       3  4  5  6  7  8  9
      10 11 12 13 14 15 16
      17 18 19 20 21 22 23
      24 25 26 27 28 29 30
      31                  

  For multipage calendars, *this* is where different output will be generated
  depending upon whether it's single-page, multipage.

  **Note:** under the hood, the output of this View itself is itself a "csv
  table". Quite literally it's a simple matrix of characters, like an
  old-school CGA text mode. The decision to render that matrix on the console
  is done *after* the View is generated, and the code to do that is common
  across all Views.  Defining things like this may turn out to be useful for
  automatic composition of UIs.

* **Controller:** (wip) The basic idea would be that the IAModel-to-View
  matching process will record enough information so that *for the types built
  into the system* Controllers *and commands to update the Model* can be
  autogenerated.

  For instance, in GUIs clicking on a number in a View ultimately derived from
  a column in the Model of type 'duration', may open a standard duration-picker
  widget. Which will result in an SQL update being performed, triggering a
  rendering update.

# Future work: automatic composition / joining two time series

A stress test of this approach will be joining two data sources e.g., joining a
calendar with an expense database.

Imagine displaying a grid in which each calendar date has a number which is
the amount of money spent on that date. And then doing interactive filtering
on what gets counted as an expense.
  
**Design goal:** No new code in either the calendar or expense parts of the
system.  The user, merely by asking that they be joined provides sufficient
signal to the system to automatically create a joined Model, a joined IAModel,
and joined View and Controller.

--------------------------------

# Notes

## Next milestone: multipage calendar

This is an interesting example. What I plan to do is to introduce the notion of
additional dimensions like "Z coordinate" in the IAModel.

The View rendering engine will contain the logic to put month calendars with
different "Z coordinate" values on separate pages, or next to each other.
Nothing in the IAModel should have to change.

## Lua implementation notes

Look at cal.lua and csvlib.lua.

* csvlib.lua defines Lua functions that are very very similar to SQL's select
  (csv_filter) and select+group (csv_group).

* One interesting addition is csv_edge_triggered_partition(). This mixes
  concepts from SQL and Mapreduce and is highly inspired by SQL's window
  functions. It sorts the entire data by a given column, then *partitions the
  rows into non-decreasing partitions by that column*, sorts the rows within a
  partition by another key, and finally runs a user-supplied "window function"
  over each partition.

  I found this operation useful when making the calendar so I'm leaving it in.
  For calendars: mark the Sundays as 1 and non-Sundays as 0, then partitioning
  by non-decreasing values of this column gives partitions composed of weeks,
  *with the first and last week's possibly-incomplete weeks correctly
  partitioned*.

  Partitioning data exactly into non-decreasing partitions doesn't seem
  parallelizable, which is likely why such a functionality isn't available in
  SQL.

eof
