# CsvLang: Pluggable Information Architecture-focused UI Framework (WIP)

## Introduction

* MVC paradigm taken to the max, with assists from relational (SQL) and
  map-reduce programming.

* Question: Can the view and controller be automatically generated? Or at least
  provide reasonable defaults out of the box?

* Why an approach like this might be useful:
  *  automatic fine-grain composition of UIs
  *  enables automatic brevity/personalization of interfaces
  *  with things like VR, the number of possibilities
     for view and control is going to increase.

* CSVLang is an exploration of the tradeoffs involved in designing a system
  that prioritizes goals like the above, especially when we don't rule out
  the use of "strange" programming models.

* Caveat: the "loss of control", the very strict separation of layers, and
  opinionated type system will probably feel strange at first. The hope is that
  the benefits far outweigh the costs.

## Core ideas

* "Everything is an SQL table": The fundamental data structure is something
  very similar to an in-memory SQL table. Some n fields together are the key,
  and everything else is the data.

* Higher-level type system: In addition to low-level types like 'integer',
  the system has higher-level types like "duration", "timepoint", "date".

* Introduces the notion of an "information architecture model" aka IAModel,
  which lies somewhere "below" the true model, but somewhere above the "view" in
  closeness to the final rendered output This is the place
  where *transformations* of the model or the computation of metadata needed
  by views and controllers live.
  
  The IAModel is *strictly additive*: the table corresponding to the model,
  along with some additional columns that the IAModel can populate. This
  definition is key: it allows multiple IAModels to be computed and
  live side-by-side for the same model.

* The hope is that if we figure out how to encode the "information architecture",
  polished views and controllers can be generated by default. Benefit: code
  reuse, harmony in views and controllers between different models.

## Prototype: Printing a quarterly calendar

To run the code:

    # Prints the calendar for July, Aug, Sep of the year 2022.
    $ lua cal.lua 2022 7 8 9

A printed calendar is somewhat weird when you think about it: the underlying data is technically
just a simple ordered set of (date, day-of-week) pairs i.e.,
it's a *one-dimensional time series*. But the canonical way humans display
that time series is in *two dimensions*.

So there's something interesting going on here that's worth thinking about.
Here's printing a calendar maps to the IA-based approach:

* **Model:** Method gen_cal_sql() in cal.lua. Returns rows mapping from a column named 'date' to a column named 'dow' that
  contains the day of the week.
  
      date,dow,yy,mm,dd
      2022-07-01,6,2022,07,01
      2022-07-02,7,2022,07,02
      2022-07-03,1,2022,07,03
      2022-07-04,2,2022,07,04
      2022-07-05,3,2022,07,05

* **IAModel:** **This is where we go from 1D to 2D**. See win_gridize() and the call to csv_partition() in cal.lua.

  Adds a column monthweek to reflect the week
  number within the month. Also encodes that the day-of-week column is usable as the X coordinate,
  and the monthweek column is usable as the Y coordinate, with the day-of-month
  being the value *at* that coordinate. Note that this is still abstract: we
  "reshaped" the data, but we didn't say anything about rows and cells as in
  a table.

  That will be a hint to the rest of the system that *this* IAModel can/should
  be matched up with some View to render the Model on a 2D output like paper,
  console, screen.

  But isn't fully specified yet so it's unclear this is actually a view.

  The column monthweek reflects the (arbitrary) human-designed way to group the
  days within a month by weeks. And weeks in turn depend on the days of the
  week. Oddly, days of the week run continously without consideration for leap
  years or the differences in the number of days in months (but they *do*
  respect leap seconds).
  
      date,dow,yy,mm,dd,monthweek,ycoor,xcoor,coorvalue
      2022-07-01,6,2022,07,01,1,1,5,1
      2022-07-02,7,2022,07,02,1,1,6,2
      2022-07-03,1,2022,07,03,2,2,0,3
      2022-07-04,2,2022,07,04,2,2,1,4
      2022-07-05,3,2022,07,05,2,2,2,5
      2022-07-06,4,2022,07,06,2,2,3,6

  **Important note:** If the calendar were for the whole year, the output from
  the IAModel will be unchanged, except for the addition of more rows.
  
* **View:** this is the part this is customized to the output device. In the example,
  a GridView capable of laying out any IAModel is used. See the call to csv_render_as_grid()
  in cal.lua.

  For console output, this amounts to constructing a matrix in memory and
  printing it, with some standard stuff like automatically resizing column
  widths. Kinda like rendering a HTML table. The X and Y coordinate hints
  in the IAModel are used here. Things like fonts, color for console output are
  all done here. Graphical output, PDF output etc *must* be different Views
  than console output.

  The hope is that a single View capable of displaying a table can be
  automatically used for a wide range of IAModels, with the rich type system
  guiding both matching and rendering policies.

             2022/7           (title is metadata from the IAModel)
      Su Mo Tu We Th Fr Sa    (row headers is metadata from the IAModel)
                      1  2
       3  4  5  6  7  8  9
      10 11 12 13 14 15 16
      17 18 19 20 21 22 23
      24 25 26 27 28 29 30
      31                  

  **Multi-page calendar:** *This* is where different output will be generated
  depending upon whether it's single-page or multipage. I can even imagine the
  multipage case being a special case of "infinite-length page" aka scrollable
  window.

* **Controller:** (wip) The basic idea would be that the IAModel-to-View matching
  process will record enough information so that *for the types built into
  the system (e.g., date, duration)* controllers *and commands to update
  the model* can be autogenerated.

  For instance, in GUIs clicking on a number in a View ultimately derived
  from a column in the Model of type 'duration', may open a standard
  duration-picker widget. Which will result in an SQL update being performed,
  triggering a rendering update.
  
# Notes on multipage calendar

This is an interesting example. What I plan to do is to introduce the notion of
additional dimensions like "Z coordinate" in the IAModel.

The View rendering engine will contain the logic to put month calendars with
different "Z coordinate" values on separate pages. Nothing in the IAModel should
have to change.

# Notes on the prototype implementation

Look at cal.lua and csvlib.lua.

* csvlib.lua defines Lua functions that are very very similar to SQL's select (csv_filter) and select+group (csv_group).

* One interesting addition is csv_edge_triggered_partition(). This mixes concepts from SQL and Mapreduce and is highly inspired by
  SQL's window functions. It sorts the entire data by a given column, then *partitions the rows into non-decreasing partitions by that column*, sorts the
  rows within a partition by another key, and finally runs a user-supplied "window function" over each partition.

  I found this operation useful when making the calendar so I'm leaving it in. For calendars: mark the Sundays as 1 and non-Sundays as 0, then partitioning by non-decreasing
  values of this column gives partitions composed of weeks, *with the first and last week's possibly-incomplete weeks correctly partitioned*.

  Partitioning data exactly into non-decreasing partitions doesn't seem parallelizable, which is likely why such a functionality isn't available in SQL.

* The real power of this approach will be apparent in the next milestone: joining a calendar with an expense database.

  Imagine displaying a grid in which each calendar date has a number which is the amount of
  money spent on that date. We would do this by simply joining the calendar time series against an expense time series and using the expense as the data
  to be displayed. Nothing else will change.
  
eof
