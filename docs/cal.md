# CsvLang: Pluggable Information Architecture-focused UI Framework (WIP)

## Introduction

* MVC paradigm taken to the max, with assists from relational (SQL) and
  map-reduce programming.

* Question: Can the view and controller be automatically generated? Or at least
  provide reasonable defaults out of the box?

* Why an approach like this might be useful:
  *  automatic fine-grain composition of UIs
  *  enables automatic brevity/personalization of interfaces
  *  with things like VR, the number of possibilities
     for view and control is going to increase.

* CSVLang is an exploration of the tradeoffs involved in designing a system
  that prioritizes goals like the above, especially when we don't rule out
  the use of "strange" programming models.

* Caveat: the "loss of control", the very strict separation of layers, and
  opinionated type system will probably feel strange at first. The hope is that
  the benefits far outweigh the costs.

## Core ideas

* "Everything is an SQL table": The fundamental data structure is something
  very similar to an in-memory SQL table. Some n fields together are the key,
  and everything else is the data.

* Higher-level type system: In addition to low-level types like 'integer',
  the system has higher-level types like "duration", "timepoint", "date".

* Introduces the notion of an "information architecture model" aka IAModel,
  which lies somewhere "below" the true model, but somewhere above the "view" in
  closeness to the final rendered output This is the place
  where *transformations* of the model or the computation of metadata needed
  by views and controllers live.
  
  The IAModel is *strictly additive*: the table corresponding to the model,
  along with some additional columns that the IAModel can populate. This
  definition is key: it allows multiple IAModels to be computed and
  live side-by-side for the same model.

* The hope is that if we figure out how to encode the "information architecture",
  polished views and controllers can be generated by default. Benefit: code
  reuse, harmony in views and controllers between different models.

## Example: Printing a quarterly calendar

A printed calendar is somewhat weird. The underlying data is technically
just a simple ordered set of (date, day-of-week) pairs i.e.,
it's a *one-dimensional time series*. But the canonical way humans display
that time series is in *two dimensions*.

Here's how I mapped the problem to the approach described above.

* Model: rows mapping from a column named 'date' to a column named 'dow' that
  contains the day of the week.

* IAModel: **Goes from 1D to 2D: adds a column monthweek to reflect the week
  number within the month, and explicitly add the day-of-month as the field
  mm**. Also encodes that the day-of-week column is usable as the X coordinate,
  and the monthweek column is usable as the Y coordinate, with the day-of-month
  being the value *at* that coordinate. Note that this is still abstract: we
  "reshaped" the data, but we didn't say anything about rows and cells as in
  a table.

  That will be a hint to the rest of the system that *this* IAModel can/should
  be matched up with some View to render the Model on a 2D output like paper,
  console, screen.

  But isn't fully specified yet so it's unclear this is actually a view.

  The column monthweek reflects the (arbitrary) human-designed way to group the
  days within a month by weeks. And weeks in turn depend on the days of the
  week. Oddly, days of the week run continously without consideration for leap
  years or the differences in the number of days in months (but they *do*
  respect leap seconds).

* View: this is the part this is customized to the output device. In the example,
  a GridView capable of laying out any IAModel is used.

  For console output, this amounts to constructing a matrix in memory and
  printing it, with some standard stuff like automatically resizing column
  widths. Kinda like rendering a HTML table. The X and Y coordinate hints
  in the IAModel are used here. Things like fonts, color for console output are
  all done here. Graphical output, PDF output etc *must* be different Views
  than console output.

  The hope is that a single View capable of displaying a table can be
  automatically used for a wide range of IAModels, with the rich type system
  guiding both matching and rendering policies.

* Controller: (wip) The basic idea would be that the IAModel-to-View matching
  process will record enough information so that *for the types built into
  the system (e.g., date, duration)* controllers *and commands to update
  the model* can be autogenerated.

  For instance, in GUIs clicking on a number in a View ultimately derived
  from a column in the Model of type 'duration', may open a standard
  duration-picker widget. Which will result in an SQL update being performed,
  triggering a rendering update.

eof
